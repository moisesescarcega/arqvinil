<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 ./static/laptop13.glb --transform --types --draco
-->

<script lang="ts">
  import type * as THREE from 'three'
  import { MeshPhysicalMaterial } from 'three';
  import { MathUtils } from 'three';
  import { colorDevices } from './variantes';
  import type { Snippet } from 'svelte'
  import { T, type Props } from '@threlte/core'
  import { useGltf, useDraco } from '@threlte/extras'

  let {
    fallback,
    error,
    children,
    ref = $bindable(),
    selectedDevice,
    colorDevice,
    ...props
  }: Props<THREE.Group> & {
    selectedDevice: number
    colorDevice: number
    ref?: THREE.Group
    children?: Snippet<[{ ref: THREE.Group }]>
    fallback?: Snippet
    error?: Snippet<[{ error: Error }]>
  } = $props()

  type GLTFResult = {
    nodes: {
      Box006: THREE.Mesh
      Box007: THREE.Mesh
      keyboard001: THREE.Mesh
      Rectangle003: THREE.Mesh
      Mesh007: THREE.Mesh
      Mesh007_1: THREE.Mesh
      Mesh007_2: THREE.Mesh
    }
    materials: {
      ['corpus.001']: THREE.MeshStandardMaterial
      ['black_plastic.002']: THREE.MeshStandardMaterial
      ['corpus_silver.001']: THREE.MeshStandardMaterial
      ['Material #29']: THREE.MeshStandardMaterial
    }
  }

  let materialSuperficie = $derived(new MeshPhysicalMaterial({
    color:colorDevices[colorDevice].color, 
    roughness: colorDevices[colorDevice].roughness,
    metalness: colorDevices[colorDevice].metalness
  }));

  let handleDimension = (dd: number) => {
    if (dd === 0) {
      return 0.11;
    } else {
      return 0.134;
    }
  }
  let handleZPosition = (dd: number) => {
    if (dd === 0) {
      return -10;
    } else {
      return -12.3;
    }
  }

  const dracoLoader = useDraco();
  const gltf = useGltf<GLTFResult>('/models/laptop13-transformed.glb', {dracoLoader})
</script>

<T.Group
  bind:ref
  dispose={false}
  {...props}
>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <T.Group
      position={[0, -0.2, handleZPosition(selectedDevice)]}
      scale={handleDimension(selectedDevice)}
      rotation.y={MathUtils.degToRad(180)}
    >
      <T.Group position={[-0.23, -94.85, 8.95]}>
        <T.Mesh
          geometry={gltf.nodes.Box006.geometry}
          material={gltf.materials['corpus.001']}
          position={[0, -3.2, 2.03]}
          rotation={[0.01, 0, 0]}
        />
        <T.Mesh
          geometry={gltf.nodes.Box007.geometry}
          material={gltf.materials['black_plastic.002']}
          position={[109.6, 1.01, 13.24]}
          rotation={[0.01, 0, 0]}
        />
        <T.Mesh
          geometry={gltf.nodes.keyboard001.geometry}
          material={gltf.materials['black_plastic.002']}
          position={[0.48, 2.77, -28.35]}
          rotation={[0.01, 0, 0]}
        />
        <T.Mesh
          geometry={gltf.nodes.Rectangle003.geometry}
          material={gltf.materials['corpus_silver.001']}
          position={[0.48, 2.93, -28.35]}
          rotation={[0.01, 0, 0]}
        />
      </T.Group>
      <T.Group position={[0, 1.3, -95.71]}>
        <T.Group
          position={[105.59, -94.69, 8.71]}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <T.Mesh
            geometry={gltf.nodes.Mesh007.geometry}
            material={materialSuperficie}
          />
          <T.Mesh
            geometry={gltf.nodes.Mesh007_1.geometry}
            material={gltf.materials['Material #29']}
          />
          <T.Mesh
            geometry={gltf.nodes.Mesh007_2.geometry}
            material={gltf.materials['black_plastic.002']}
          />
        </T.Group>
      </T.Group>
    </T.Group>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref: ref ?? {} as THREE.Group })}
</T.Group>
